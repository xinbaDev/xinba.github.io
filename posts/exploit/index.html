<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>如何搭建一个充满漏洞的网站 &#183; Alex's Blog</title><link rel=stylesheet href=/xinba.github.io/css/style.css><link rel=stylesheet href=/xinba.github.io/css/fonts.css><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=32x32 href=/xinba.github.io/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/xinba.github.io/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/xinba.github.io/images/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title="Alex's Blog"></head><body><nav class=nav><div class=nav-container><a href=/xinba.github.io/><h2 class=nav-title>Alex's Blog</h2></a><ul><li><a href=/xinba.github.io/posts><span>Posts</span></a></li></ul></div></nav><main><div class=post><div class=post-info><span>Written by</span>
Alex<br><span>on&nbsp;</span><time datetime="2019-09-19 19:39:11 +1100 +1100">September 19, 2019</time></div><h1 class=post-title>如何搭建一个充满漏洞的网站</h1><div class=post-line></div><p>最近在研究OWASP TOP10的时候接触到<a href=https://github.com/bkimminich/juice-shop>juiceshop</a>这个集各种漏洞于一身的开源web app。大概看了一下， 一个小小的web app里面各种各样从A1到A9类型的漏洞就有88个。</p><h2 id=a1--注入>A1 : 注入</h2><p>在用户和网站的交互当中，有许多需要用户提供参数的地方。这些参数有些又会通过网页服务器传入到其他服务器中进行运行，比如数据库，第三方应用。如果这些用户可控的参数没有进行验证过滤而直接传入到其他服务器，就有可能产生注入。</p><p>案例1</p><p>首先看看Login Admin的例子。</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function login () {

    ...
    
  return (req, res, next) =&gt; {
    verifyPreLoginChallenges(req)
    models.sequelize.query('SELECT * FROM Users WHERE email = \'' + 
    (req.body.email || '') + '\' AND password = \'' + 
    insecurity.hash(req.body.password || '') + '\' 
    AND deletedAt IS NULL', { model: models.User, plain: true })
      .then((authenticatedUser) =&gt; {
        let user = utils.queryResultToJson(authenticatedUser)
        
        ...
        
        afterLogin(user, res, next)
  }
</code></pre><p>这是一个典型的sql注入漏洞代码，email参数没有进行验证而直接用来构造raw sql语句。用户可以将email设置为<code>' or 1=1 --</code>是整个sql语句变成<code>SELECT * FROM Users WHERE email ='' or 1=1 -- ....</code>, 从而导致数据库执行错误指令，返回所有用户信息。</p><p>案例2</p><p>Nosql注入</p><pre><code class="language-javascript=" data-lang="javascript=">
module.exports = function trackOrder () {
  return (req, res) =&gt; {
    req.params.id = utils.trunc(decodeURIComponent(req.params.id), 40)
    db.orders.find({ $where: &quot;this.orderId === '&quot; + req.params.id + &quot;'&quot; }).then(order =&gt; {
      const result = utils.queryResultToJson(order)
      if (result.data[0] === undefined) {
        result.data[0] = { orderId: req.params.id }
      }
      res.json(result)
    }, () =&gt; {
      res.status(400).json({ error: 'Wrong Param' })
    })
  }
}
</code></pre><p>这是个典型的nosql注入的漏洞，orderid没有进行验证过滤，导致当用户输入id=' || true || &lsquo;的时候，nosql语句变成<code>db.orders.find({ $where: this.orderId === '' || true || '' })</code>, 结果返回所有的orders。</p><p>案例3</p><p>除了数据库的注入，还有一些注入会直接调用服务器的系统程序，导致远程代码执行。比如利用模板引擎来执行远程代码。在Juiceshop中，用户名是用模板引擎Pug产生的，使用#{1+1}作为用户名会发现网页上显示用户名为2。</p><h2 id=a2--失效的身份认证和会话管理>A2 : 失效的身份认证和会话管理</h2><p>案例1</p><p>Login CISO</p><p>Oauth2是非常常见的用户验证的业界标准，广泛用于第三方登录。在juiceshop中，oauth2登录的实现有很大的问题。</p><p>前端代码：</p><pre><code class="language-javascript=" data-lang="javascript=">
ngOnInit () {
    this.userService.oauthLogin(this.parseRedirectUrlParams()['access_token']).subscribe((profile: any) =&gt; {
        let password = btoa(profile.email.split('').reverse().join(''))
        this.userService.save({ email: profile.email, password: password, passwordRepeat: password }).subscribe(() =&gt; {
        this.login(profile)
        }, () =&gt; this.login(profile))
    }, (error) =&gt; {
        this.invalidateSession(error)
        this.router.navigate(['/login'])
    })
}

  
login (profile: any) {
    this.userService.login({
    // 将第三方的用户邮件，以及通过邮箱生成的密码，加上oauth=true传入后端
        email: profile.email, password: 
        btoa(profile.email.split('').reverse().join('')), oauth: true 
    }).subscribe((authentication) =&gt; {
      this.cookieService.put('token', authentication.token)
      localStorage.setItem('token', authentication.token)
      sessionStorage.setItem('bid', authentication.bid)
      this.userService.isLoggedIn.next(true)
      this.router.navigate(['/'])
    }, (error) =&gt; {
      this.invalidateSession(error)
      this.router.navigate(['/login'])
    })
}
</code></pre><p>后端代码：</p><pre><code class="language-javascript=" data-lang="javascript=">
exports.userEmailFrom = ({ headers }) =&gt; {
  return headers ? headers['x-user-email'] : undefined
}

module.exports = function login () {

    ...

    const rememberedEmail = insecurity.userEmailFrom(req)
    // 当选择记住邮件的方式登录时，只要加上oauth的参数，
    // 以及x-user-email的header就可以实现登录。
    if (rememberedEmail &amp;&amp; req.body.oauth) {
      models.User.findOne({ where: { email: rememberedEmail } }).then(rememberedUser =&gt; {
        user = utils.queryResultToJson(rememberedUser)
        afterLogin(user, res, next)
      })
    }
    
    ...
}
</code></pre><p>通过这个oauth2的登录漏洞，黑客只要知道用户的邮箱就可以实现登录。</p><h2 id=a3--敏感信息泄露>A3 : 敏感信息泄露</h2><p>案例 ftp路径泄漏</p><p>在about.component.html中，</p><pre><code class=language-htmlmixed data-lang=htmlmixed>&lt;a href=&quot;/ftp/legal.md&quot; aria-label=&quot;Link to the Terms of Use&quot; translate&gt;LINK_TERMS_OF_USE&lt;/a&gt;
</code></pre><p>我们可以看到服务器有ftp的folder，然后访问这个这个地址，返回：</p><p><img src=https://i.imgur.com/mH4rDrm.png alt></p><p>里面有一系列的文件，包括一些服务器配置文件，和coupon的备份。当点击下载其中的文件时，服务器报错说只能下载.md和.pdf结尾的文件。但是这段服务器代码故意留下的漏洞。</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function servePublicFiles () {
  return ({ params, query }, res, next) =&gt; {
    const file = params.file

    if (!file.includes('/')) {
      verify(file, res, next)
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }

  function verify (file, res, next) {
    // 先验证文件是否已md,pdf结尾
    if (file &amp;&amp; (endsWithWhitelistedFileType(file) || 
        (file === 'incident-support.kdbx'))) {
      // 但是之后又对文件名进行处理，导致之后的file已经和传入得不一致
      file = insecurity.cutOffPoisonNullByte(file)
      res.sendFile(path.resolve(__dirname, '../ftp/', file))
    } else {
      res.status(403)
      next(new Error('Only .md and .pdf files are allowed!'))
    }
  }


  function endsWithWhitelistedFileType (param) {
    return utils.endsWith(param, '.md') || utils.endsWith(param, '.pdf')
  }
}

exports.cutOffPoisonNullByte = str =&gt; {
  const nullByte = '%00'
  if (utils.contains(str, nullByte)) {
    return str.substring(0, str.indexOf(nullByte))
  }
  return str
}
</code></pre><h2 id=a4xml外部实体漏洞xxe>A4：XML外部实体漏洞（XXE）</h2><p>案例 远程读取服务器的文件</p><p>在Juiceshop中，用户可以通过上传xml文件，触发XXE。漏洞代码如下：</p><pre><code class="language-javascript=" data-lang="javascript=">function handleXmlUpload ({ file }, res, next) {
  if (utils.endsWith(file.originalname.toLowerCase(), '.xml')) {
    if (file.buffer &amp;&amp; !utils.disableOnContainerEnv()) { 
    // XXE attacks in Docker/Heroku containers regularly cause &quot;segfault&quot; crashes
      const data = file.buffer.toString()
      try {
        const sandbox = { libxml, data }
        vm.createContext(sandbox)
        
        // 没有对用户上传的文件（输入）进行验证
        const xmlDoc = vm.runInContext('libxml.parseXml(data, { noblanks: true, noent: true, nocdata: true })', sandbox, { timeout: 2000 })
        const xmlString = xmlDoc.toString(false)
        res.status(410)
        next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + utils.trunc(xmlString, 200) + ' (' + file.originalname + ')'))
      } catch (err) {
        if (utils.contains(err.message, 'Script execution timed out')) {
          if (utils.notSolved(challenges.xxeDosChallenge)) {
            utils.solve(challenges.xxeDosChallenge)
          }
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          res.status(410)
          next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + err.message + ' (' + file.originalname + ')'))
        }
      }
    } else {
      res.status(410)
      next(new Error('B2B customer complaints via file upload have been deprecated for security reasons (' + file.originalname + ')'))
    }
  }
  res.status(204).end()
}
</code></pre><p>使用一个简单的外部实体引用，就可以触发这个远程文件读取的漏洞。</p><pre><code class="language-xml=" data-lang="xml=">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
        &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;

&lt;test&gt;
    &lt;foo&gt;&amp;xxe;&lt;/foo&gt;
&lt;/test&gt;		
</code></pre><h2 id=a5--缺少功能级访问控制>A5 : 缺少功能级访问控制</h2><p>在网站中，一些功能是用户所特有的。如果没有对这些个功能进行权限认证/或者错误的权限认证就会导致越权访问漏洞。</p><p>案例1 操作他人的购物车</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports.addBasketItem = function addBasketItem () {
  return (req, res, next) =&gt; {
    var result = utils.parseJsonCustom(req.rawBody)
    var productIds = []
    var basketIds = []
    var quantities = []

    for (var i = 0; i &lt; result.length; i++) {
      if (result[i].key === 'ProductId') {
        productIds.push(result[i].value)
      } else if (result[i].key === 'BasketId') {
        basketIds.push(result[i].value)
      } else if (result[i].key === 'quantity') {
        quantities.push(result[i].value)
      }
    }

    const user = insecurity.authenticatedUsers.from(req)
    // 这里对basketid进行验证
    if (user &amp;&amp; basketIds[0] &amp;&amp; basketIds[0] !== 'undefined' &amp;&amp; user.bid != basketIds[0]) { // eslint-disable-line eqeqeq
      res.status(401).send('{\'error\' : \'Invalid BasketId\'}')
    } else {
      // 但是这里存入的却不一定是验证过的basketid
      const basketItem = {
        ProductId: productIds[productIds.length - 1],
        BasketId: basketIds[basketIds.length - 1],
        quantity: quantities[quantities.length - 1]
      }

      const basketItemInstance = models.BasketItem.build(basketItem)
      basketItemInstance.save().then((basketItem) =&gt; {
        basketItem = {
          status: 'success',
          data: basketItem
        }
        res.json(basketItem)
      }).catch(error =&gt; {
        next(error)
      })
    }
  }
}

</code></pre><p>通过对api/BasketItems发起一个以{&ldquo;ProductId&rdquo;:30, &ldquo;BasketId&rdquo;:&ldquo;4&rdquo;, &ldquo;quantity&rdquo;:1， &ldquo;BasketId&rdquo;:&ldquo;3&rdquo; }为payload的post请求，就可以触发这个漏洞。导致往basketid为3的购物车中加入一个product id为30的商品。</p><h2 id=a6--配置错误>A6 : 配置错误</h2><p>案例 弃用的接口没有正确的关闭</p><p>在html中，只允许pdf,zip这两种文件上传</p><pre><code class="language-htmlmixed=" data-lang="htmlmixed=">&lt;input _ngcontent-rgy-c18=&quot;&quot; accept=&quot;.pdf,.zip&quot; aria-label=&quot;Input area for 
uploading a single invoice PDF or XML B2B order file or a ZIP archive 
containing multiple invoices or orders&lt;!----&gt;&quot; id=&quot;file&quot; ng2fileselect=&quot;&quot; 
style=&quot;margin-left: 10px;&quot; type=&quot;file&quot;&gt;
</code></pre><p>但是在实际的js中，还有xml这种文件可以上传。</p><pre><code class="language-javascript=" data-lang="javascript=">public uploader: FileUploader = new FileUploader({
    url: environment.hostServer + '/file-upload',
    authToken: `Bearer ${localStorage.getItem('token')}`,
    allowedMimeType: [ 'application/pdf' , 'application/xml', 'text/xml' , 
    'application/zip', 'application/x-zip-compressed', 'multipart/x-zip'],
    maxFileSize: 100000
})
</code></pre><p>在juiceshop中，还有个明显的配置错误就是没有将错误信息过滤。导致一旦后端服务出错，相关的stack trace都返回给客户端。还有一些目录，比如ftp，应该设置让用户不能直接list目录下的文件。</p><h2 id=a7--跨站脚本-xss>A7 : 跨站脚本-XSS</h2><p>案例 储存型XSS攻击</p><p>在/api/feedbacks这个api中， comment这个参数并没有很好的验证和过滤。漏洞代码如下：</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = (sequelize, { STRING, INTEGER }) =&gt; {
  const Feedback = sequelize.define('Feedback', {
    comment: {
      type: STRING,
      set (comment) {
        // 这里虽然有过滤操作，但是使用的lib: &quot;sanitize-html&quot;: &quot;1.4.2&quot; 有
        // 漏洞，不能过滤嵌套的脚本
        const sanitizedComment = insecurity.sanitizeHtml(comment)
        this.setDataValue('comment', sanitizedComment)
      }
    },
  })

  Feedback.associate = ({ User }) =&gt; {
    Feedback.belongsTo(User) // no FK constraint to allow anonymous feedback posts
  }

  return Feedback
}
</code></pre><p>可以通过<code>&lt;&lt;script>Foo&lt;/script>iframe src="javascript:alert(xss)"></code>来触发这个漏洞。</p><h2 id=a8不安全的反序列化漏洞>A8：不安全的反序列化漏洞</h2><p>在一些比较复杂的post请求中可以发现，比如前端传递的参数是一个数组，这是就需要后端进行反序列化，将客户端传递过来的字符串转化成内存里的数组。这个过程一不小心就会出现远程执行漏洞。</p><p>在juiceshop中，产生反序列化漏洞的代码如下：</p><pre><code class="language-javascript=" data-lang="javascript=">module.exports = function b2bOrder () {
  return ({ body }, res, next) =&gt; {
    if (!utils.disableOnContainerEnv()) {
      const orderLinesData = body.orderLinesData || ''
      try {
        const sandbox = { safeEval, orderLinesData }
        vm.createContext(sandbox)
        // safeEval直接运行代码，导致漏洞
        vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })
        res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
      } catch (err) {
        if (err.message &amp;&amp; err.message.match(/Script execution timed out.*/)) {
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          next(err)
        }
      }
    } else {
      res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
    }
  }
}
</code></pre><p>可以通过{&ldquo;orderLinesData&rdquo;: &ldquo;(function dos() { while(true); })()"}进行触发。</p><h2 id=a9--使用含有已知漏洞的组件>A9 : 使用含有已知漏洞的组件</h2><p>在juiceshop中用了好几个有漏洞的组件。其中甚至有一些是“恶意”的组件（但是并不会造成安全问题），因为typo的原因而被引入。</p><p>这里主要介绍一下express-jwt这个组件。在juiceshop中使用的这个组件的版本存在<a href=https://snyk.io/vuln/npm:jws:20160726>伪造token的漏洞</a>。简单来讲，jws.verify中没有验证algorithm这个参数，导致攻击者可以更改algorithm来达到伪造token的目的。</p><p>但是仔细看一下，express-jwt的代码其实没问题，而是其依赖的jsonwebtoken出问题了。而jsonwebtoken也不是直接导致漏洞的原因，而是其依赖的jws出了问题。具体产生漏洞的代码如下：</p><pre><code class="language-javascript=" data-lang="javascript=">function jwsVerify(jwsSig, secretOrKey) {
  jwsSig = toString(jwsSig);
  const signature = signatureFromJWS(jwsSig);
  const securedInput = securedInputFromJWS(jwsSig);
  // algo这个没有验证，导致用户可以修改algo。
  const algo = jwa(algoFromJWS(jwsSig));
  return algo.verify(securedInput, signature, secretOrKey);
}
</code></pre><p>更详细完整的修复commit，可以看<a href=https://github.com/brianloveswords/node-jws/commit/585d0e1e97b6747c10cf5b7689ccc5618a89b299>这里</a>。</p><h2 id=a10不足的记录和漏洞监控>A10：不足的记录和漏洞监控</h2><p>在整个web app中，没有任何的出错记录和漏洞监控。</p></div><div class=pagination><a href=/xinba.github.io/posts/systemcall/ class="left arrow">&#8592;</a>
<a href=/xinba.github.io/posts/owasp/ class="right arrow">&#8594;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2022-05-16 07:34:25.632438178 +0000 UTC m=+0.054879367">2022</time> Alex. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>
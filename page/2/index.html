<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>Alex's Blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link href=/index.xml rel=alternate type=application/rss+xml title="Alex's Blog"></head><body><nav class=nav><div class=nav-container><a href=/><h1 class=nav-title>Alex's Blog</h1></a><ul><li><a href=/posts><span>Posts</span></a></li></ul></div></nav><main><div class=catalogue><a href=/posts/exploit/ class=catalogue-item><div><time datetime="2019-09-19 19:39:11 +1100 +1100" class=catalogue-time>September 19, 2019</time><h2 class=catalogue-title>如何搭建一个充满漏洞的网站</h2><div class=catalogue-line></div><p>最近了解到了一个叫strace的神器，可以看到程序运行时的系统调用。于是写了个简单程序来做分析。这篇文章主要分析一个简单的c程序（如上）在运行时所需要的系统调用。但是不会深入分析系统调用的具体实现，如果有兴趣可以看我写的另一篇文章《一个系统调用的linux内核(v5.25)实现》, 里面有详细分析setdomainname的系统调用的内核实现。这里主要从更高的层次去分析，程序运行时为什么需要这些系统调用。</p></div></a><a href=/posts/systemcall/ class=catalogue-item><div><time datetime="2019-08-23 19:39:11 +1100 +1100" class=catalogue-time>August 23, 2019</time><h2 class=catalogue-title>一个系统调用的linux内核实现</h2><div class=catalogue-line></div><p>前一篇文章研究分析了一个简单c程序运行时所需的系统调用。而这篇文章则主要分析，系统调用setdomainname时，到底发生了什么？</p></div></a><a href=/posts/setdomainname/ class=catalogue-item><div><time datetime="2019-08-20 19:39:11 +1100 +1100" class=catalogue-time>August 20, 2019</time><h2 class=catalogue-title>一个简单的c程序在linux下所需要的系统调用</h2><div class=catalogue-line></div><p>最近了解到了一个叫strace的神器，可以看到程序运行时的系统调用。于是写了个简单程序来做分析。这篇文章主要分析一个简单的c程序（如上）在运行时所需要的系统调用。但是不会深入分析系统调用的具体实现，如果有兴趣可以看我写的另一篇文章《一个系统调用的linux内核(v5.25)实现》, 里面有详细分析setdomainname的系统调用的内核实现。这里主要从更高的层次去分析，程序运行时为什么需要这些系统调用。</p></div></a><a href=/posts/quickjs/ class=catalogue-item><div><time datetime="2019-08-01 21:47:00 +1100 +1100" class=catalogue-time>August 1, 2019</time><h2 class=catalogue-title>Quickjs UAF漏洞分析，利用以及修复</h2><div class=catalogue-line></div><p>Quickjs是一个轻量的js引擎，先放张benchmark。可以看到作为一个轻量的js引擎，Quickjs是十分优秀的。在评分上甚至和Hermes这种重型js引擎并驾齐驱。虽然和v8相比还是有不小差距，但是毕竟是一个人开发的，而且相比v8，Quickjs才620kb。</p></div></a><a href=/posts/dos/ class=catalogue-item><div><time datetime="2019-07-07 18:33:00 +1100 +1100" class=catalogue-time>July 7, 2019</time><h2 class=catalogue-title>对DoS（Denial Of Service）攻击初探索</h2><div class=catalogue-line></div><p>最近刷微博的时候看到一篇写的很有趣的文章《“记一次被DDoS敲诈的历程”》, 像看故事一样，我一口气把它看完了。作为一个后端程序员，我对DoS攻击早有耳闻，也对这一块的攻防技术和原理充满兴趣。这篇文章一下子让我想起来之前看到过的一系列关于DoS的文章，比如《DDoS 攻击的防范教程》, 《DD4BC：一个专门用DDoS敲诈勒索比特币的黑客组织》, 《Linux 内核 SCTP 协议漏洞分析与复现 （CVE-2019-8956）》, 《GitHub已遭基于Memcached的DDoS攻击 规模达1.35Tbps》。这次我打算自己对DoS(包含DDoS)这块进行一次系统的探索，而这篇文章就是探索中的一些记录。</p></div></a><a href=/posts/emailverification/ class=catalogue-item><div><time datetime="2019-06-30 20:17:00 +1100 +1100" class=catalogue-time>June 30, 2019</time><h2 class=catalogue-title>如何确认Email是否真实存在</h2><div class=catalogue-line></div><p>最近公司在做promotion,导致有许多刷注册的帐号。这些帐号都留下虚假的邮箱，导致发送确认邮箱的邮件经常无法送达，导致bounce rate提高了不少，甚至一度超过aws ses的警戒线。根据aws的规定，超过一定界限，会停止发送邮件的服务。为了防止被禁用，如何识别这些虚假邮箱，降低bounce rate就成了我需要解决的问题。</p></div></a></div><div class=pagination><a href=/ class="left arrow">&#8592;</a>
<span>2</span></div></main><footer><span>&copy; <time datetime="2022-02-25 10:06:15.320923013 +0000 UTC m=+0.078399778">2022</time> Alex. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>
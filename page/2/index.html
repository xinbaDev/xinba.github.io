<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>Alex's Blog</title><link rel=stylesheet href=/xinba.github.io/css/style.css><link rel=stylesheet href=/xinba.github.io/css/fonts.css><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=32x32 href=/xinba.github.io/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/xinba.github.io/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/xinba.github.io/images/apple-touch-icon.png><link href=/xinba.github.io/index.xml rel=alternate type=application/rss+xml title="Alex's Blog"></head><body><nav class=nav><div class=nav-container><a href=/xinba.github.io/><h1 class=nav-title>Alex's Blog</h1></a><ul><li><a href=/xinba.github.io/posts><span>Posts</span></a></li></ul></div></nav><main><div class=catalogue><a href=https://xinbadev.github.io/xinba.github.io/posts/performance/ class=catalogue-item><div><time datetime="2020-04-11 11:14:22 +1100 +1100" class=catalogue-time>April 11, 2020</time><h2 class=catalogue-title>关于服务优化的调研和思考</h2><div class=catalogue-line></div><p>最近某台服务器的cpu使用率一直居高不下，直接导致用户等待时间增加，用户体验明显变差。甚至还出现了服务器几乎当机的情况。所以想研究一下有没有办法通过代码层面优化的方式减少cpu的使用率。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/fallocate/ class=catalogue-item><div><time datetime="2020-03-14 17:14:11 +1100 +1100" class=catalogue-time>March 14, 2020</time><h2 class=catalogue-title>Fallocate的那些事</h2><div class=catalogue-line></div><p>fallocate是linux中的一个system call，他的主要作用是分配硬盘区块（block allocation）。我最初接触到这个命令是在本地测试一个程序的bug，这个bug需要在硬盘满了的时候才会触发。当时的硬盘空间还绰绰有余，需要想个办法把它快速填满。我知道linux中有个叫dd的命令可以往硬盘里写入指定大小的文件，我之前创建swap的时候就是用这个命令。但是这个命令用于创建大文件来说太久了。于是我想起之前在stackoverflow看到的另一个命令fallocate。据介绍，这个命令比dd快的多。一用之下，果然如此。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/architecture/ class=catalogue-item><div><time datetime="2020-02-23 21:30:11 +1100 +1100" class=catalogue-time>February 23, 2020</time><h2 class=catalogue-title>记一次服务器事故以及对架构的一些思考</h2><div class=catalogue-line></div><p>在2020.02.20的早上8点半左右有用户报告网站无法访问，8点40分收到通知，赶紧通过手机访问网站确认，主站的前端服务器出了问题。于是紧急通过远程连接登录到aws的云端服务器，发现服务器仍然在运行，排除EC2服务器挂掉的情况。接着查node server， 发现PM2还在运行，但是application已经挂掉。 于是怀疑是硬盘空间不足。一查硬盘空间，果然已经满了。于是马上通过aws的console加空间，然后重启服务器。重启服务器以及相关应用后，服务器于8点49分恢复正常访问。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/wireguard/ class=catalogue-item><div><time datetime="2019-11-24 12:39:11 +1100 +1100" class=catalogue-time>November 24, 2019</time><h2 class=catalogue-title>通过架设wireguard我学到了什么</h2><div class=catalogue-line></div><p>最早接触wireguard应该是一年前左右的时候。当时觉得openvpn使用起来不是很稳定，想找一些更好的vpn开源程序。而且当时我也对vpn技术感兴趣，想找一个state of art来学习一下。于是wireguard就进入了我的眼帘。了解到wiredguard甚至进入了linux内核后，更加让我下定决心要花时间去学习架设这个vpn。虽然网上的教程很多，而且wireguard也是以容易架设著称，但是我的架设之路并不是一帆风顺。因为对wireguard不熟悉，也踩了不少坑，走了不少弯路。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/owasp/ class=catalogue-item><div><time datetime="2019-09-21 17:21:11 +1100 +1100" class=catalogue-time>September 21, 2019</time><h2 class=catalogue-title>OWASP TOP 10(2017)</h2><div class=catalogue-line></div><p>《OWASP Top 10 - 2017 The Ten Most Critical Web Application Security Risks》总结了Web应用程序最可能、最常见、最危险的十大漏洞。虽然离报告发布已经过去了两年，但是这份报告对web安全介绍还是十分有意义的。尤其是对于刚入门web安全的工程师来说，这份报告是一个非常好的指南，可以帮助IT公司和开发团队规范应用程序开发流程和测试流程，提高Web产品的安全性。本文将会根据这些漏洞类型，进行分类分析，并提出一些我个人的看法。最后会根据这套报告，对一些网站进行测试。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/exploit/ class=catalogue-item><div><time datetime="2019-09-19 19:39:11 +1100 +1100" class=catalogue-time>September 19, 2019</time><h2 class=catalogue-title>如何搭建一个充满漏洞的网站</h2><div class=catalogue-line></div><p>最近了解到了一个叫strace的神器，可以看到程序运行时的系统调用。于是写了个简单程序来做分析。这篇文章主要分析一个简单的c程序（如上）在运行时所需要的系统调用。但是不会深入分析系统调用的具体实现，如果有兴趣可以看我写的另一篇文章《一个系统调用的linux内核(v5.25)实现》, 里面有详细分析setdomainname的系统调用的内核实现。这里主要从更高的层次去分析，程序运行时为什么需要这些系统调用。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/systemcall/ class=catalogue-item><div><time datetime="2019-08-23 19:39:11 +1100 +1100" class=catalogue-time>August 23, 2019</time><h2 class=catalogue-title>一个系统调用的linux内核实现</h2><div class=catalogue-line></div><p>前一篇文章研究分析了一个简单c程序运行时所需的系统调用。而这篇文章则主要分析，系统调用setdomainname时，到底发生了什么？</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/setdomainname/ class=catalogue-item><div><time datetime="2019-08-20 19:39:11 +1100 +1100" class=catalogue-time>August 20, 2019</time><h2 class=catalogue-title>一个简单的c程序在linux下所需要的系统调用</h2><div class=catalogue-line></div><p>最近了解到了一个叫strace的神器，可以看到程序运行时的系统调用。于是写了个简单程序来做分析。这篇文章主要分析一个简单的c程序（如上）在运行时所需要的系统调用。但是不会深入分析系统调用的具体实现，如果有兴趣可以看我写的另一篇文章《一个系统调用的linux内核(v5.25)实现》, 里面有详细分析setdomainname的系统调用的内核实现。这里主要从更高的层次去分析，程序运行时为什么需要这些系统调用。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/quickjs/ class=catalogue-item><div><time datetime="2019-08-01 21:47:00 +1100 +1100" class=catalogue-time>August 1, 2019</time><h2 class=catalogue-title>Quickjs UAF漏洞分析，利用以及修复</h2><div class=catalogue-line></div><p>Quickjs是一个轻量的js引擎，先放张benchmark。可以看到作为一个轻量的js引擎，Quickjs是十分优秀的。在评分上甚至和Hermes这种重型js引擎并驾齐驱。虽然和v8相比还是有不小差距，但是毕竟是一个人开发的，而且相比v8，Quickjs才620kb。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/dos/ class=catalogue-item><div><time datetime="2019-07-07 18:33:00 +1100 +1100" class=catalogue-time>July 7, 2019</time><h2 class=catalogue-title>对DoS（Denial Of Service）攻击初探索</h2><div class=catalogue-line></div><p>最近刷微博的时候看到一篇写的很有趣的文章《“记一次被DDoS敲诈的历程”》, 像看故事一样，我一口气把它看完了。作为一个后端程序员，我对DoS攻击早有耳闻，也对这一块的攻防技术和原理充满兴趣。这篇文章一下子让我想起来之前看到过的一系列关于DoS的文章，比如《DDoS 攻击的防范教程》, 《DD4BC：一个专门用DDoS敲诈勒索比特币的黑客组织》, 《Linux 内核 SCTP 协议漏洞分析与复现 （CVE-2019-8956）》, 《GitHub已遭基于Memcached的DDoS攻击 规模达1.35Tbps》。这次我打算自己对DoS(包含DDoS)这块进行一次系统的探索，而这篇文章就是探索中的一些记录。</p></div></a></div><div class=pagination><a href=/xinba.github.io/ class="left arrow">&#8592;</a>
<a href=/xinba.github.io/page/3/ class="right arrow">&#8594;</a>
<span>2</span></div></main><footer><span>&copy; <time datetime="2022-07-25 01:04:50.767785127 +0000 UTC m=+0.140042070">2022</time> Alex. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>
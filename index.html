<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><title>Alex's Blog</title><link rel=stylesheet href=/xinba.github.io/css/style.css><link rel=stylesheet href=/xinba.github.io/css/fonts.css><link rel=icon href=favicon.ico><link rel=icon type=image/png sizes=32x32 href=/xinba.github.io/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/xinba.github.io/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/xinba.github.io/images/apple-touch-icon.png><link href=/xinba.github.io/index.xml rel=alternate type=application/rss+xml title="Alex's Blog"></head><body><nav class=nav><div class=nav-container><a href=/xinba.github.io/><h1 class=nav-title>Alex's Blog</h1></a><ul><li><a href=/xinba.github.io/posts><span>Posts</span></a></li></ul></div></nav><main><div class=catalogue><a href=https://xinbadev.github.io/xinba.github.io/posts/sql/ class=catalogue-item><div><time datetime="2021-06-13 19:33:00 +1100 +1100" class=catalogue-time>June 13, 2021</time><h2 class=catalogue-title>记一次对sql的调试和优化(Postgres query planner)</h2><div class=catalogue-line></div><p>最近在工作中碰到一个很有趣的sql问题。几乎同样的raw sql，最后执行出来的时间居然相差百倍不止。通过对这个问题的调试研究，对sql的执行过程（postgres）以及相应的优化有了更深的认识。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/linux/ class=catalogue-item><div><time datetime="2020-12-21 16:50:11 +1100 +1100" class=catalogue-time>December 21, 2020</time><h2 class=catalogue-title>系统调用open时到底发生了什么？（Linux内核学习笔记）</h2><div class=catalogue-line></div><p>在计算中系统中，最重要的有三类资源，分别是cpu, memory, disk，他们也是编程语言经常需要打交道的三类资源。比如cpu对应了语言的并发性(例如GO以高并发著称)，memory则涉及到语言的垃圾回收的机制，disk则是涉及到创建文件/删除文件等。应该说相比前两者，disk的部分是相对简单的。以python为例，一个简单的打开/创建文件，写入“hello world”，然后关闭文件的程序代码如下：</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/goodarch/ class=catalogue-item><div><time datetime="2020-08-04 19:58:11 +1100 +1100" class=catalogue-time>August 4, 2020</time><h2 class=catalogue-title>什么是好的架构？</h2><div class=catalogue-line></div><p>使用AWS的云服务也有好几年了，最近在准备aws certified solution architect的考试。中间不仅对aws cloud的大大小小的功能系统的复习了一遍，同时也读了不少aws的白皮书。 这些天来一个问题又慢慢浮现在我的脑海中，挥之不去。到底什么是好的架构，或者说好的架构有什么特点？ 之前一直有在思考这方面的问题，也读过不少优秀的博客。印象中许多架构师的分享都是介绍如何利用各种框架技术实现高可用/高可靠性，高性能的服务。在大开眼界的同时，也给我一个感觉，只要掌握了各种优秀框架技术（适用场景以及利弊等）就可以作出好的架构。这次系统的看了aws的各种白皮书，让我又重新思考什么是好的架构，并且有了新的认识。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/debug2/ class=catalogue-item><div><time datetime="2020-04-20 09:17:22 +1100 +1100" class=catalogue-time>April 20, 2020</time><h2 class=catalogue-title>记一次生产服务器debug(下)</h2><div class=catalogue-line></div><p>在上一篇我们分析服务器的异常情况，并对导致异常的原因有了一个初步的判断。但是我们漏掉了一个关键的线索没有具体的分析，那就是cpu steal time。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/debug1/ class=catalogue-item><div><time datetime="2020-04-14 10:27:22 +1100 +1100" class=catalogue-time>April 14, 2020</time><h2 class=catalogue-title>记一次生产服务器debug(上)</h2><div class=catalogue-line></div><p><ol><li>17:18分，nginx的error日志里开始出现upstream 110 connection timeout的记录。2. 17:22分， netdata开始报警20min steal cpu = 18.2%， 并很快上升31.8%。 3. 17:27分， 群里开始有人报告相应服务不能访问。 4. 17:30分， 远程登录服务器后发现cpu使用率非常的高（主要是node server在占用），基本在80-100使用率，但是服务器的访问量并不高。</li></ol></p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/performance/ class=catalogue-item><div><time datetime="2020-04-11 11:14:22 +1100 +1100" class=catalogue-time>April 11, 2020</time><h2 class=catalogue-title>关于服务优化的调研和思考</h2><div class=catalogue-line></div><p>最近某台服务器的cpu使用率一直居高不下，直接导致用户等待时间增加，用户体验明显变差。甚至还出现了服务器几乎当机的情况。所以想研究一下有没有办法通过代码层面优化的方式减少cpu的使用率。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/fallocate/ class=catalogue-item><div><time datetime="2020-03-14 17:14:11 +1100 +1100" class=catalogue-time>March 14, 2020</time><h2 class=catalogue-title>Fallocate的那些事</h2><div class=catalogue-line></div><p>fallocate是linux中的一个system call，他的主要作用是分配硬盘区块（block allocation）。我最初接触到这个命令是在本地测试一个程序的bug，这个bug需要在硬盘满了的时候才会触发。当时的硬盘空间还绰绰有余，需要想个办法把它快速填满。我知道linux中有个叫dd的命令可以往硬盘里写入指定大小的文件，我之前创建swap的时候就是用这个命令。但是这个命令用于创建大文件来说太久了。于是我想起之前在stackoverflow看到的另一个命令fallocate。据介绍，这个命令比dd快的多。一用之下，果然如此。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/architecture/ class=catalogue-item><div><time datetime="2020-02-23 21:30:11 +1100 +1100" class=catalogue-time>February 23, 2020</time><h2 class=catalogue-title>记一次服务器事故以及对架构的一些思考</h2><div class=catalogue-line></div><p>在2020.02.20的早上8点半左右有用户报告网站无法访问，8点40分收到通知，赶紧通过手机访问网站确认，主站的前端服务器出了问题。于是紧急通过远程连接登录到aws的云端服务器，发现服务器仍然在运行，排除EC2服务器挂掉的情况。接着查node server， 发现PM2还在运行，但是application已经挂掉。 于是怀疑是硬盘空间不足。一查硬盘空间，果然已经满了。于是马上通过aws的console加空间，然后重启服务器。重启服务器以及相关应用后，服务器于8点49分恢复正常访问。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/wireguard/ class=catalogue-item><div><time datetime="2019-11-24 12:39:11 +1100 +1100" class=catalogue-time>November 24, 2019</time><h2 class=catalogue-title>通过架设wireguard我学到了什么</h2><div class=catalogue-line></div><p>最早接触wireguard应该是一年前左右的时候。当时觉得openvpn使用起来不是很稳定，想找一些更好的vpn开源程序。而且当时我也对vpn技术感兴趣，想找一个state of art来学习一下。于是wireguard就进入了我的眼帘。了解到wiredguard甚至进入了linux内核后，更加让我下定决心要花时间去学习架设这个vpn。虽然网上的教程很多，而且wireguard也是以容易架设著称，但是我的架设之路并不是一帆风顺。因为对wireguard不熟悉，也踩了不少坑，走了不少弯路。</p></div></a><a href=https://xinbadev.github.io/xinba.github.io/posts/owasp/ class=catalogue-item><div><time datetime="2019-09-21 17:21:11 +1100 +1100" class=catalogue-time>September 21, 2019</time><h2 class=catalogue-title>OWASP TOP 10(2017)</h2><div class=catalogue-line></div><p>《OWASP Top 10 - 2017 The Ten Most Critical Web Application Security Risks》总结了Web应用程序最可能、最常见、最危险的十大漏洞。虽然离报告发布已经过去了两年，但是这份报告对web安全介绍还是十分有意义的。尤其是对于刚入门web安全的工程师来说，这份报告是一个非常好的指南，可以帮助IT公司和开发团队规范应用程序开发流程和测试流程，提高Web产品的安全性。本文将会根据这些漏洞类型，进行分类分析，并提出一些我个人的看法。最后会根据这套报告，对一些网站进行测试。</p></div></a></div><div class=pagination><a href=/xinba.github.io/page/2/ class="right arrow">&#8594;</a>
<span>1</span></div></main><footer><span>&copy; <time datetime="2022-03-25 03:29:54.898151617 +0000 UTC m=+0.066933364">2022</time> Alex. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>